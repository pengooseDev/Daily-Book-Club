**ğŸ”— ì°¸ê³ ìë£Œ**

-

# ì„ íƒë¬¸

---

- ì¡°ê±´ë¬¸ì„ ì–˜ê¸°í•œë‹¤.

### if-else

```java
if(ì¡°ê±´ë¬¸ 1) {
  ë¡œì§ A
} else if(ì¡°ê±´ë¬¸ 2) {
  ë¡œì§ B
} else if(ì¡°ê±´ë¬¸ 3) {
  ë¡œì§ C
} else {
  ë¡œì§ D
}
```

### switch-case

```java
switch(ë³€ìˆ˜ or ì¡°ê±´ë¬¸) {
  case ê°’1: ë¡œì§A; break;
  case ê°’2: ë¡œì§B;
  default: ë¡œì§C;
}
```

# ë°˜ë³µë¬¸

---

ë°˜ë³µë¬¸ì´ë€ í”„ë¡œê·¸ë¨ ë‚´ì—ì„œ ë˜‘ê°™ì€ ëª…ë ¹ì„ ì¼ì • íšŸìˆ˜ë§Œí¼ ë°˜ë³µí•˜ì—¬ ìˆ˜í–‰í•˜ë„ë¡ ì œì–´í•˜ëŠ” ëª…ë ¹ë¬¸ì…ë‹ˆë‹¤.

í”„ë¡œê·¸ë¨ì´ ì²˜ë¦¬í•˜ëŠ” ëŒ€ë¶€ë¶„ì˜ ì½”ë“œëŠ” ë°˜ë³µì ì¸ í˜•íƒœê°€ ë§ìœ¼ë¯€ë¡œ, ê°€ì¥ ë§ì´ ì‚¬ìš©ë˜ëŠ” ì œì–´ë¬¸ ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤.

ìë°”ì—ì„œ ì‚¬ìš©ë˜ëŠ” ëŒ€í‘œì ì¸ ë°˜ë³µë¬¸ì˜ í˜•íƒœëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

1. while ë¬¸
2. do / while ë¬¸
3. for ë¬¸

### whileë¬¸

```java
int i = 0;

while (i < 5) {
	System.out.println("whileë¬¸ " + i + " ë²ˆì§¸");
	i++;
}
System.out.println("while ë¬¸ì´ ì¢…ë£Œëœ í›„ ë³€ìˆ˜ iì˜ ê°’ì€ " + i + "ì…ë‹ˆë‹¤.");
```

### do / whileë¬¸

```java
int i = 0;

do {
		System.out.println("do/whileë¬¸ " + i + " ë²ˆì§¸");
	i++
} while(i < 5);
System.out.println("do/while ë¬¸ì´ ì¢…ë£Œëœ í›„ ë³€ìˆ˜ iì˜ ê°’ì€ " + i + "ì…ë‹ˆë‹¤.");
```

### forë¬¸

```java
for(ì´ˆê¸°ì‹; ì¡°ê±´ì‹; ì¦ê°ì‹) {
	ì¡°ê±´ì‹ì˜ ê²°ê³¼ê°€ ì°¸ì¸ ë™ì•ˆ ë°˜ë³µì ìœ¼ë¡œ ì‹¤í–‰í•˜ê³ ì í•˜ëŠ” ëª…ë ¹ë¬¸
}
```

- ê³¼ì œ(ë¯¸ì™„ë£Œ)

  # (ê³¼ì œ 0) JUnit 5 í•™ìŠµí•˜ê¸°

  # (ê³¼ì œ 1) live-study ëŒ€ì‹œ ë³´ë“œë¥¼ ë§Œë“œëŠ” ì½”ë“œ ì‘ì„±

  # (ê³¼ì œ 2) LinkedListë¥¼ êµ¬í˜„í•˜ê¸°

  # (ê³¼ì œ 3) Stackì„ êµ¬í˜„í•˜ê¸°

    ```java
    import java.io.IOException;
    import java.util.Scanner;
    
    public class Main {
        public static void main(String[] args) throws IOException {
            Scanner sc = new Scanner(System.in);
            int n = sc.nextInt();
            customStack customStack = new customStack(n);
            StringBuilder sb = new StringBuilder();
    
            for (int i = 0; i < n; i++) {
                String command = sc.next();
    
                switch (command) {
    
                    case "push":
                        customStack.push(sc.nextInt());
                        break;
    
                    case "top":
                        sb.append(customStack.peek()).append("\n");
                        break;
    
                    case "size":
                        sb.append(customStack.size()).append("\n");
                        break;
    
                    case "empty":
                        sb.append(customStack.empty()).append("\n");
                        break;
    
                    case "pop":
                        sb.append(customStack.pop()).append("\n");
                        break;
                }
            }
            System.out.println(sb);
        }
    }
    
    class customStack {
        int[] stack;
        int size = 0;
    
        public customStack(int n) {
            stack = new int[n];
        }
    
        public void push(int num) {
            stack[size] = num;
            size++;
        }
    
        public int pop() {
            if (size == 0) {
                return -1;
            }
    
            int num = stack[size - 1];
            stack[size - 1] = 0;
            size--;
            return num;
        }
    
        public int size() {
            return size;
        }
    
        public int empty() {
            if (size == 0) return 1;
            else return 0;
        }
    
        public int peek() {
            if (size == 0) return - 1;
            return stack[size - 1];
        }
    }
    ```

  # (ê³¼ì œ 4) ì•ì„œ ë§Œë“  ListNodeë¥¼ ì‚¬ìš©í•´ì„œ Stack êµ¬í˜„

  # (ê³¼ì œ 5) Queueë¥¼ êµ¬í˜„

    ```java
    import java.io.BufferedReader;
    import java.io.IOException;
    import java.io.InputStreamReader;
    import java.util.StringTokenizer;
    
    public class Main {
        public static void main(String[] args) throws IOException {
            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
            int n = Integer.parseInt(br.readLine());
            StringTokenizer st;
            StringBuilder sb = new StringBuilder();
    
            customQueue<Integer> customQueue = new customQueue<>();
    
            for (int i = 0; i < n; i++) {
                st = new StringTokenizer(br.readLine());
                String command = st.nextToken();
    
                switch (command) {
                    case "push":
                        customQueue.push(Integer.parseInt(st.nextToken()));
                        break;
    
                    case "pop":
                        sb.append(customQueue.pop()).append("\n");
                        break;
    
                    case "size":
                        sb.append(customQueue.size()).append("\n");
                        break;
    
                    case "empty":
                        sb.append(customQueue.empty()).append("\n");
                        break;
    
                    case "front":
                        sb.append(customQueue.front()).append("\n");
                        break;
    
                    case "back":
                        sb.append(customQueue.back()).append("\n");
                        break;
                }
            }
            System.out.println(sb);
        }
    }
    
    class customQueue<T> {
    
        transient  Node<T> first;
        transient  Node<T> last;
        int size = 0;
    
        public void push(T e) {
            final Node<T> l = last;
            final Node<T> newNode = new Node<>(l, e, null);
            last = newNode;
            if (l == null)
                first = newNode;
            else
                l.next = newNode;
            size++;
        }
    
        public String pop() {
            if (size ==0) return "-1";
            final Node<T> f = first;
            final T element = f.item;
            final Node<T> next = f.next;
            f.item = null;
            f.next = null;
            first = next;
            if (next == null)
                last = null;
            else
                next.prev = null;
            size--;
            return element.toString();
        }
    
        public int size() {
            return size;
        }
    
        public int empty() {
            if (size == 0) return 1;
            else return 0;
        }
    
        public T front() {
            if (first == null) return (T) "-1";
            return first.item;
        }
    
        public T back() {
            if (last == null) return (T) "-1";
            return last.item;
        }
    
        private class Node<E> {
            E item;
            Node<E> next;
            Node<E> prev;
    
            Node(Node<E> prev, E element, Node<E> next) {
                this.item = element;
                this.next = next;
                this.prev = prev;
            }
        }
    }
    ```